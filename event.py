"""Assignment 1 - Grocery Store Events (Task 2)

This file should contain all of the classes necessary to model the different
kinds of events in the simulation.
"""

from store import *


class Event:
    """An event.

    Events have an ordering based on the event timestamp in non-ascending
    order. Events with older timestamps are less than those with newer
    timestamps.

    === Attributes ===
    @type timestamp: int
        A timestamp for this event.
    @type line: CheckoutLine
        The line related to the event.
    """
    def __init__(self, timestamp):
        """Initialize an Event with a given timestamp.

        @type self: Event
        @type timestamp: int
            A timestamp for this event.
            Precondition: must be a non-negative integer.
        @rtype: None

        >>> Event(7).timestamp
        7
        """
        self.timestamp = timestamp
        self.line = None

    def __eq__(self, other):
        """Return whether this Event is equal to <other>.

        Two events are equal if they have the same timestamp.

        @type self: Event
        @type other: Event
        @rtype: bool

        >>> first = Event(1)
        >>> second = Event(2)
        >>> first == second
        False
        >>> second.timestamp = first.timestamp
        >>> first == second
        True
        """
        return self.timestamp == other.timestamp

    def __ne__(self, other):
        """Return True iff this Event is not equal to <other>.

        @type self: Event
        @type other: Event
        @rtype: bool

        >>> first = Event(1)
        >>> second = Event(2)
        >>> first != second
        True
        >>> second.timestamp = first.timestamp
        >>> first != second
        False
        """
        return not self.__eq__(other)

    def __lt__(self, other):
        """Return True iff this Event is less than <other>.

        @type self: Event
        @type other: Event
        @rtype: bool

        >>> first = Event(1)
        >>> second = Event(2)
        >>> first < second
        True
        >>> second < first
        False
        """
        return self.timestamp < other.timestamp

    def __le__(self, other):
        """Return True iff this Event is less than or equal to <other>.

        @type self: Event
        @type other: Event
        @rtype: bool

        >>> first = Event(1)
        >>> second = Event(2)
        >>> first <= first
        True
        >>> first <= second
        True
        >>> second <= first
        False
        """
        return self.timestamp <= other.timestamp

    def __gt__(self, other):
        """Return True iff this Event is greater than <other>.

        @type self: Event
        @type other: Event
        @rtype: bool

        >>> first = Event(1)
        >>> second = Event(2)
        >>> first > second
        False
        >>> second > first
        True
        """
        return not self.__le__(other)

    def __ge__(self, other):
        """Return True iff this Event is greater than or equal to <other>.

        @type self: Event
        @type other: Event
        @rtype: bool

        >>> first = Event(1)
        >>> second = Event(2)
        >>> first >= first
        True
        >>> first >= second
        False
        >>> second >= first
        True
        """
        return not self.__lt__(other)

    def do(self, store):
        """Perform this Event.

        Call methods on <store> to update its state according to the
        meaning of the event. Note: the "business logic" of what actually
        happens inside a grocery store should be handled in the GroceryStore
        class, not in any Event classes.

        Return a list of new events spawned by this event (making sure the
        timestamps are correct).

        @type self: Event
        @type store: GroceryStore
        @rtype: list[Event]
            A list of events generated by performing this event.
        """
        raise NotImplementedError


class JoinLine(Event):
    """E new costumer joins a checkout line.

    A costumer joins a line according to a particular algorithm, detailed in
    the store.py file.

    === Attributes ===
    @type cos: Costumer
        The costumer related to this event.
    """
    def __init__(self, timestamp):
        """Initialize this subclass.

        @type timestamp: int
        @rtype: None

        >>> e = JoinLine(35)
        >>> e.timestamp
        35
        """
        super(JoinLine, self).__init__(timestamp)
        self.cos = None

    def do(self, store):
        """Perform this event.

        @type self: JoinLine
        @type store: GroceryStore
        @rtype: list[Event]
            A list of events generated by performing this event.
        """
        self.line = store.assign_to_line(self.cos)
        self.line.costumers_list.append(self.cos)
        if self.cos.joined_store is None:
            self.cos.joined_store = self.timestamp
        event_spawned = []
        if len(self.line.costumers_list) == 1:
            event = CheckingOut(self.timestamp)
            event.cos = self.cos
            event.line = self.line
            event_spawned.append(event)
        return event_spawned


class CheckingOut(Event):
    """A costumer starts to checkout.

    A costumer takes different amount of time to checkout depending on the line
    he/she is in.

    === Attributes ===
    @type cos: Costumer
        The costumer related to this event.
    """
    def __init__(self, timestamp):
        """Initialize this subclass.

        @type timestamp: int
        @rtype: None

        >>> e = CheckingOut(95)
        >>> e.timestamp
        95
        """
        super(CheckingOut, self).__init__(timestamp)
        self.cos = None

    def do(self, store):
        """Perform this event.

        @type self: CheckingOut
        @type store: GroceryStore
        @rtype: list[Event]
            A list of events generated by performing this event.
        """
        time_taken = self.line.time_to_checkout(self.cos.items)
        event = FinishCheckingOut(self.timestamp + time_taken)
        event.cos = self.cos
        event.line = self.line
        return [event]


class FinishCheckingOut(Event):
    """A costumer finishes to checkout.

    When a costumer finishes to checkout the next one in line begins to checkout
    (if there is any).

    === Attributes ===
    @type cos: Costumer
        The costumer related to this event.
    """
    def __init__(self, timestamp):
        """Initialize this subclass.

        @type timestamp: int
        @rtype: None

        >>> e = FinishCheckingOut(10)
        >>> e.timestamp
        10
        """
        super(FinishCheckingOut, self).__init__(timestamp)
        self.cos = None

    def do(self, store):
        """Perform this event.

        @type self: FinishCheckout
        @type store: GroceryStore
        @rtype: list[Event]
            A list of events generated by performing this event.
        """
        self.line.costumers_list.remove(self.cos)
        event_spawned = []
        if len(self.line.costumers_list) > 0:
            event = CheckingOut(self.timestamp)
            event.cos = self.line.costumers_list[0]
            event.line = self.line
            event_spawned.append(event)
        self.cos.total_time_waited = self.timestamp - self.cos.joined_store
        return event_spawned


class CloseLine(Event):
    """A checkout line closes.

    If a checkout line closes the costumer in front of the line keeps his/her
    spot and the others (if there are any) are assigned to available lines.
    """
    def __init__(self, timestamp):
        """Initialize this subclass.

        @type timestamp: int
        @rtype: None

        >>> e = CloseLine(1)
        >>> e.timestamp
        1
        """
        super(CloseLine, self).__init__(timestamp)

    def do(self, store):
        """Perform this event.

        @type self: CloseLine
        @type store: GroceryStore
        @rtype: list[Event]
            A list of events generated by performing this event.
        """
        store.close(self.line)
        events_spawned = []
        if len(self.line.costumers_list) > 1:
            for i in range(len(self.line.costumers_list[1:])):
                event = JoinLine(self.timestamp + i)
                event.cos = self.line.costumers_list[-1]
                self.line.costumers_list.pop()
                events_spawned.append(event)
        return events_spawned


def create_event_list(filename):
    """Return a list of Events based on raw list of events in <filename>.

    Precondition: the file stored at <filename> is in the format specified
    by the assignment handout.

    @type filename: str
        The name of a file that contains the list of events.
    @rtype: list[Event]
    """
    events = []
    with open(filename, 'r') as file:
        for line in file:
            tokens = line.split()
            if tokens[1] == 'Arrive':
                event = JoinLine(int(tokens[0]))
                event.cos = Costumer(tokens[2], int(tokens[-1]))
            else:
                event = CloseLine(int(tokens[0]))
                event.line = int(tokens[-1])
                # See the comment in simulation.py regarding the line above.

            events.append(event)
    return events
